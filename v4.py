# -*- coding: utf-8 -*-
"""V4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MHTaunbItG2XgAvRT-r8cHg4NfY-7PBE
"""

import numpy as np
import pandas as pd

# ===============================
# PARAMETROS MATERIALES Y GEOMETRÍA
# ===============================
fy = 4200        # Esfuerzo fluencia acero [kgf/cm²]
Es = 2.1e6       # Módulo Young acero [kgf/cm²]
fc = 250         # Resistencia compresión hormigón [kgf/cm²]
lw = 30          # Largo sección muro [cm]
N_imp = 120000    # Ca
rga axial aplicada (compresión positiva) [kgf]
n_fibras = 200   # Cantidad de fibras en el concreto

xj_steel = np.array([5, 17.5, 30, 42.5, 55])     # Ubicación barras acero [cm]
n_1 = np.array([3, 2, 2, 2, 3])                  # Nº de barras por línea
diam_1 = np.array([22, 22, 22, 22, 22])          # Diámetro de barras [mm]
As = (np.pi / 4) * ((diam_1 / 10)**2) * n_1      # Área total acero por fila [cm²]

# ===============================
# BLOQUES DE HORMIGÓN
# ===============================
x_inicio = np.array([0.0])
x_fin = np.array([30.0])
bj = np.array([60.0])
largo = x_fin - x_inicio
xj_conc = x_inicio + largo / 2
Aj = largo * bj
bloques = [{
    "x_inicio": x_inicio[i],
    "x_fin": x_fin[i],
    "xj [cm]": xj_conc[i],
    "b [cm]": bj[i],
    "largo [cm]": largo[i],
    "Aj [cm²]": Aj[i]
} for i in range(len(x_inicio))]
Ag = np.sum(Aj)

Ast = np.sum(As)
fcAjxj = np.sum([b["Aj [cm²]"] * b["xj [cm]"] * 0.85 * fc for b in bloques])
Asfyxj = np.sum(As * xj_steel * fy)
denom = 0.85 * fc * Ag + Ast * fy
xp = (fcAjxj + Asfyxj) / denom  # Centroide combinado

# ===============================
# MODELOS DE MATERIALES
# ===============================
def sigma_acero_realista(es, Es, fy, ey=None, esu=0.01, ef=0.02):
    if ey is None:
        ey = fy / Es
    abs_es = abs(es)
    if abs_es <= ey:
        return Es * es
    elif abs_es <= esu:
        return fy * np.sign(es)
    elif abs_es <= ef:
        degradacion = fy * (1 - (abs_es - esu) / (ef - esu))
        return degradacion * np.sign(es)
    else:
        return 0

def sigma_hormigon_postfalla(ec, fc, eo=0.002, ecu=0.003, ec_max=0.008):
    if ec <= 0:
        return 0
    elif ec <= eo:
        return fc * (2 * ec / eo - (ec / eo)**2)
    elif ec <= ecu:
        return fc
    elif ec <= ec_max:
        return fc * (1 - 0.8 * (ec - ecu) / (ec_max - ecu))
    else:
        return 0

# ===============================
# CÁLCULO FUERZAS INTERNAS
# ===============================
def calcular_Tj(xj_steel, As, phi, c):
    return np.array([Asj * sigma_acero_realista(phi * (xj - c), Es, fy) for xj, Asj in zip(xj_steel, As)])

def calcular_Cj(bloques, phi, c, xp, n_fibras):
    dx = lw / n_fibras
    Cj, Mj = [], []
    for i in range(n_fibras):
        xj = dx * (i + 0.5)
        bloque = next(b for b in bloques if b["x_inicio"] <= xj <= b["x_fin"])
        Aj_fibra = bloque["b [cm]"] * dx
        eci = 0 if xj > c else -phi * (xj - c)
        fc_i = sigma_hormigon_postfalla(eci, fc)
        C = Aj_fibra * fc_i
        M = C * (xp - xj)
        Cj.append(C)
        Mj.append(M)
    return np.array(Cj), np.array(Mj)

# ===============================
# BUSQUEDA DEL EJE NEUTRO (c)
# ===============================
def encontrar_c(ec, bloques, xj_steel, As, Es, fy, fc, lw, N_imp, xp, n_fibras, tol=0.001, max_iter=200):
    c_min, c_max = 0.1, lw
    mejor_phi = None
    mejor_M = None
    min_error = float("inf")
    for _ in range(max_iter):
        c = (c_min + c_max) / 2
        phi = ec / c
        Tj = calcular_Tj(xj_steel, As, phi, c)
        Cj, _ = calcular_Cj(bloques, phi, c, xp, n_fibras)
        equilibrio = np.sum(Cj) - np.sum(Tj)
        error = abs(equilibrio - N_imp)
        if error < min_error:
            mejor_phi = phi
            dx = lw / n_fibras
            xj_fibra = np.array([dx * (i + 0.5) for i in range(n_fibras)])
            Mj_T = -Tj * (xp - xj_steel)
            Mj_C = Cj * (xp - xj_fibra)
            mejor_M = np.sum(Mj_T) + np.sum(Mj_C)
            min_error = error
        if error < tol:
            break
        if equilibrio < N_imp:
            c_min = c
        else:
            c_max = c
    return mejor_phi, mejor_M

# ===============================
# FUNCIÓN PRINCIPAL PARA INTEGRACIÓN EXACTA
# ===============================
def modelo_integracion_exacta(ec_list):
    resultados = []
    for ec in ec_list:
        try:
            phi, M = encontrar_c(ec, bloques, xj_steel, As, Es, fy, fc, lw, N_imp, xp, n_fibras)
            resultados.append((ec, phi, M))
        except:
            resultados.append((ec, None, None))
    return pd.DataFrame(resultados, columns=["εc", "Curvatura φ", "Momento M [kgf·cm]"])

import matplotlib.pyplot as plt
import pandas as pd

ec_list = np.linspace(0.0001, 0.05, 50)
df_integracion = modelo_integracion_exacta(ec_list)

# Elimina valores nulos, por si hay deformaciones sin solución de equilibrio
df_validos = df_integracion.dropna()

# Gráfico Momento - Curvatura
plt.figure(figsize=(8, 5))
plt.plot(df_validos["Curvatura φ"], df_validos["Momento M [kgf·cm]"], marker='o', linestyle='-', label="Integración Exacta")
plt.xlabel("Curvatura φ [1/cm]")
plt.ylabel("Momento M [kgf·cm]")
plt.title("Diagrama Momento–Curvatura")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Exportar a un archivo Excel
nombre_archivo = "Curvatura_Momento.xlsx"
df_validos[["εc","Curvatura φ", "Momento M [kgf·cm]"]].to_excel(nombre_archivo, index=False)

print(f"Datos exportados a {nombre_archivo}")