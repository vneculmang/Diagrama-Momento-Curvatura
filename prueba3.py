# -*- coding: utf-8 -*-
"""Prueba3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JK-3XepLq2pUWvlHgcXoiSTqhT4UETl5
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

#===============
#PARÁMETROS DE ENTRADA
#==============
fy = 4200
Es = 2.1e6
fc = 250
ecu = 0.003
eo = 0.002
ey = 0.002
N_imp = 490.0
lw = 300

#Disposicion de los aceros de refuerzo
#ubicación de las lineas de acero en centimetros
xj_steel_input = np.array([
    4.9, 20.0, 35.1, 40.1, 60.1, 80.1, 100.1, 120.1, 140.1,
    160.1, 180.1, 200.1, 220.1, 240.1, 260.1, 274.9, 285.0, 295.1
])
#Diametros de las filas de acero en milimetros
diam_1 = np.array([
    18, 18, 18, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 18, 18, 18
])
#Cantidad de aceros por linea
n_1 = np.array([
    3, 2, 3, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 3, 2, 3
])

#Muro T hormigón
#Largos y anchos desde el eje 0 (izquierdo)
x_inicio = np.array([0.0, 40.0, 260.0])
x_fin = np.array([40.0, 260.0, 300.0])
bj = np.array([40.0, 30.0, 40.0])

#============
#ACERO Y HORMIGÓN
#============

#Calcular el area de acero por cada fila o columna de barras
def calcular_columnas_refuerzo(xj_steel, diam_1, n_1, diam_2=None, n_2=None):
    if diam_2 is None:
        diam_2 = np.zeros_like(diam_1)
    if n_2 is None:
        n_2 = np.zeros_like(n_1)
    columnas = []
    for i in range(len(xj_steel)):
        As_i = (np.pi / 4) * ((diam_1[i] / 10)**2 * n_1[i] + (diam_2[i] / 10)**2 * n_2[i])
        columnas.append({
            "xj [cm]": xj_steel[i],
            "φ1 [mm]": diam_1[i],
            "n1": n_1[i],
            "φ2 [mm]": diam_2[i],
            "n2": n_2[i],
            "As [cm²]": As_i
        })
    return columnas

#output para usarlo
columnas_refuerzo = calcular_columnas_refuerzo(xj_steel_input, diam_1, n_1)
xj_steel = np.array([col["xj [cm]"] for col in columnas_refuerzo])
As = np.array([col["As [cm²]"] for col in columnas_refuerzo])

def calcular_bloques_hormigon(x_inicio, x_fin, bj):
    largo = x_fin - x_inicio
    xj = x_inicio + largo / 2
    Aj = largo * bj
    bloques = []
    for i in range(len(x_inicio)):
        bloques.append({
            "x_inicio": x_inicio[i],
            "x_fin": x_fin[i],
            "xj [cm]": xj[i],
            "b [cm]": bj[i],
            "largo [cm]": largo[i],
            "Aj [cm²]": Aj[i]
        })
    Ag = np.sum(Aj)
    return bloques, Ag

#retorna las secciones del muro
bloques, Ag = calcular_bloques_hormigon(x_inicio, x_fin, bj)

#Calculooo
def calcular_Ast(columnas):
    return sum(col["As [cm²]"] for col in columnas)

def calcular_Po(fc, Ag, Ast, fy):
    return (0.85 * fc * (Ag - Ast) + fy * Ast) / 1000

def calcular_phi_Pn_max(fc, Ag, Ast, fy):
    return 0.65 * 0.8 * (0.85 * fc * (Ag - Ast) + fy * Ast) / 1000

def calcular_Pu_max(fc, Ag):
    return 0.35 * fc * Ag / 1000

def calcular_phi(ec, c):
    return ec / c

Ast = calcular_Ast(columnas_refuerzo)
Po = calcular_Po(fc, Ag, Ast, fy)
phi_Pn_max = calcular_phi_Pn_max(fc, Ag, Ast, fy)
Pu_max = calcular_Pu_max(fc, Ag)

#modelo bilineal: lineal hasta ey, luego constante hasta esu, despues esfuerzo cer0
#defini que el alargamiento maximo es 10% TENGO QUE REVISAR SI ES ASI TB PARA HSS (0.06-0.1)
def sigma_acero(es, Es, fy, ey=0.002, esu=0.1):
    if abs(es) <= ey:
        return Es * es #elastico
    elif abs(es) <= esu:
        return fy * np.sign(es) #plastico
    else:
        return 0 #fractura
#fuerzas internas traaccion
def calcular_Tj(xj_steel, As, phi, c):
    Tj = []
    for xj, Asj in zip(xj_steel, As):
        esj = phi * (xj - c)
        fs = sigma_acero(esj, Es, fy)
        T = Asj * fs / 1000
        Tj.append(T)
    return np.array(Tj)

#parabolico hasta eo, constante hasta ecu, lineal hasta ec_max, luego cero
def sigma_hormigon(ec, fc, eo=0.002, ecu=0.003, ec_max=0.008):
    if ec <= 0:
        return 0 #SOLO TRACCION
    elif ec <= eo:
        return fc * (2 * ec / eo - (ec / eo)**2)  #elastica no lineal o parabolica
    elif ec <= ecu:
        return fc #esfuerzo maximo
    elif ec <= ec_max:
        return fc * (1 - 0.85 * (ec - ecu) / (ec_max - ecu)) #disminuye hasta 0
    else:
        return 0 #colapso

#fuerzas internas compresion, ve dentro de qué bloque de muro esta y busca la geometria correspondiente a b
def calcular_Cj(bloques, phi, c, xp, n_fibras=200):
    Cj, Mj = [], []
    dx = lw / n_fibras
    for i in range(n_fibras):
        xj = dx * (i + 0.5)
        bloque = next(b for b in bloques if b["x_inicio"] <= xj <= b["x_fin"])
        Aj_fibra = bloque["b [cm]"] * dx
        eci = 0 if xj > c else -phi * (xj - c)
        fc_i = sigma_hormigon(eci, fc)
        C = Aj_fibra * fc_i / 1000
        M = C * (xp - xj) / 100
        Cj.append(C)
        Mj.append(M)
    return np.array(Cj), np.array(Mj)

#centroide original
def calcular_xp():
    fcAjxj = sum(b["Aj [cm²]"] * b["xj [cm]"] * 0.85 * fc for b in bloques)
    Asfyxj = sum(col["As [cm²]"] * col["xj [cm]"] * fy for col in columnas_refuerzo)
    denom = 0.85 * fc * Ag + Ast * fy
    return (fcAjxj + Asfyxj) / denom

#para c equilibrio con N_imp para cada ec de ec_list encuentra c y calcula el momento CON METODO BISECCION
def encontrar_c_para_ec(ec, xp, tol=0.001, max_iter=100): #AJUSTAR
    c_min, c_max = 0.1, lw
    mejor_phi = None
    mejor_M = None
    min_error = float("inf")
    for _ in range(max_iter):
        c = (c_min + c_max) / 2
        phi = calcular_phi(ec, c)
        Tj = calcular_Tj(xj_steel, As, phi, c)
        Cj, _ = calcular_Cj(bloques, phi, c, xp)
        equilibrio = np.sum(Cj) - np.sum(Tj)
        error = abs(equilibrio - N_imp)
        if error < min_error:
            mejor_phi = phi
            dx = lw / 200 #divido el largo total del muro en 200 fibras para buscar cada valor
            xj_fibra = np.array([dx * (i + 0.5) for i in range(200)])
            Mj_T = -Tj * (xp - xj_steel) / 100
            Mj_C = Cj * (xp - xj_fibra) / 100
            mejor_M = np.sum(Mj_T) + np.sum(Mj_C)
            min_error = error
        if error < tol:
            break
        if equilibrio < N_imp:
            c_min = c
        else:
            c_max = c
    return mejor_phi, mejor_M

#================
# LISTA DE EC Y EJECUCIÓN
#=================
#ec_list  = np.linspace(0, 0.003, 50)
#ec_list = np.array([0.0000001, 0.0001, 0.000293333, 0.000486667, 0.00068, 0.000873333, 0.001066667, 0.00126, 0.001453333, 0.001646667, 0.00184, 0.002033333, 0.002226667, 0.00242, 0.002613333, 0.002806667, 0.003]) #macro usm
#ec_list = np.linspace(0.0001, 0.008, 100)  # hasta 0.8%
ec_list = np.linspace(0.0001, 0.02, 100)

#================
# RESULTADOS
#=================

#resultados es una lista de tuplas
df_resultados = pd.DataFrame(resultados, columns=["εc", "Curvatura φ", "Momento M [T·m]"])
df_resultados["Curvatura φ (formato)"] = df_resultados["Curvatura φ"].apply(
    lambda x: f"{float(x):.2E}" if pd.notnull(x) else "")

print(df_resultados[["εc", "Curvatura φ (formato)", "Momento M [T·m]"]])

#eliminar valores nulos grafico
df_validos = df_resultados.dropna(subset=["Curvatura φ", "Momento M [T·m]"])

#=====================
# GRAFICO
#=====================
plt.figure(figsize=(8, 5))
plt.plot(df_validos["Curvatura φ"], df_validos["Momento M [T·m]"], marker='o', linewidth=2)
plt.gca().xaxis.set_major_formatter(ticker.FormatStrFormatter('%.1E'))

plt.xlabel("Curvatura φ [1/cm]")
plt.ylabel("Momento M [T·m]")
plt.title("Diagrama Momento–Curvatura")
plt.grid(True)
plt.tight_layout()
plt.show()

